// Code generated by "protoc-gen-entpb". DO NOT EDIT

package bare

import (
	context "context"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	horus "khepri.dev/horus"
	ent "khepri.dev/horus/ent"
	conf "khepri.dev/horus/ent/conf"
	predicate "khepri.dev/horus/ent/predicate"
)

type ConfServiceServer struct {
	db *ent.Client
	horus.UnimplementedConfServiceServer
}

func NewConfServiceServer(db *ent.Client) *ConfServiceServer {
	return &ConfServiceServer{db: db}
}
func (s *ConfServiceServer) Create(ctx context.Context, req *horus.CreateConfRequest) (*horus.Conf, error) {
	q := s.db.Conf.Create()
	q.SetID(req.GetId())
	q.SetValue(req.GetValue())

	res, err := q.Save(ctx)
	if err != nil {
		return nil, ToStatus(err)
	}

	return ToProtoConf(res), nil
}
func (s *ConfServiceServer) Delete(ctx context.Context, req *horus.GetConfRequest) (*emptypb.Empty, error) {
	p, err := GetConfSpecifier(req)
	if err != nil {
		return nil, err
	}
	if _, err := s.db.Conf.Delete().Where(p).Exec(ctx); err != nil {
		return nil, ToStatus(err)
	}

	return &emptypb.Empty{}, nil
}
func (s *ConfServiceServer) Get(ctx context.Context, req *horus.GetConfRequest) (*horus.Conf, error) {
	q := s.db.Conf.Query()
	if p, err := GetConfSpecifier(req); err != nil {
		return nil, err
	} else {
		q.Where(p)
	}

	res, err := QueryConfWithEdgeIds(q).Only(ctx)
	if err != nil {
		return nil, ToStatus(err)
	}

	return ToProtoConf(res), nil
}
func QueryConfWithEdgeIds(q *ent.ConfQuery) *ent.ConfQuery {

	return q
}
func (s *ConfServiceServer) Update(ctx context.Context, req *horus.UpdateConfRequest) (*horus.Conf, error) {
	id, err := GetConfId(ctx, s.db, req.GetKey())
	if err != nil {
		return nil, err
	}

	q := s.db.Conf.UpdateOneID(id)
	if v := req.Value; v != nil {
		q.SetValue(*v)
	}

	res, err := q.Save(ctx)
	if err != nil {
		return nil, ToStatus(err)
	}

	return ToProtoConf(res), nil
}
func ToProtoConf(v *ent.Conf) *horus.Conf {
	m := &horus.Conf{}
	m.Id = v.ID
	m.DateCreated = timestamppb.New(v.DateCreated)
	m.Value = v.Value
	m.DateUpdated = timestamppb.New(v.DateUpdated)
	return m
}
func GetConfId(ctx context.Context, db *ent.Client, req *horus.GetConfRequest) (string, error) {
	var r string
	k := req.GetKey()
	if t, ok := k.(*horus.GetConfRequest_Id); ok {
		return t.Id, nil
	}

	p, err := GetConfSpecifier(req)
	if err != nil {
		return r, err
	}

	v, err := db.Conf.Query().Where(p).OnlyID(ctx)
	if err != nil {
		return r, ToStatus(err)
	}

	return v, nil
}

func GetConfSpecifier(req *horus.GetConfRequest) (predicate.Conf, error) {
	switch t := req.GetKey().(type) {
	case *horus.GetConfRequest_Id:
		return conf.IDEQ(t.Id), nil
	case *horus.GetConfRequest_Query:
		if req, err := ResolveGetConfQuery(req); err != nil {
			return nil, err
		} else {
			return GetConfSpecifier(req)
		}
	case nil:
		return nil, status.Errorf(codes.InvalidArgument, "key not provided")
	default:
		return nil, status.Errorf(codes.Unimplemented, "unknown type of key")
	}
}

func ResolveGetConfQuery(req *horus.GetConfRequest) (*horus.GetConfRequest, error) {
	t, ok := req.Key.(*horus.GetConfRequest_Query)
	if !ok {
		return req, nil
	}

	q := t.Query

	return horus.ConfById(q), nil
}
