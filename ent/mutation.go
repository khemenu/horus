// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"khepri.dev/horus/ent/account"
	"khepri.dev/horus/ent/identity"
	"khepri.dev/horus/ent/invitation"
	"khepri.dev/horus/ent/membership"
	"khepri.dev/horus/ent/predicate"
	"khepri.dev/horus/ent/silo"
	"khepri.dev/horus/ent/team"
	"khepri.dev/horus/ent/token"
	"khepri.dev/horus/ent/user"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount    = "Account"
	TypeIdentity   = "Identity"
	TypeInvitation = "Invitation"
	TypeMembership = "Membership"
	TypeSilo       = "Silo"
	TypeTeam       = "Team"
	TypeToken      = "Token"
	TypeUser       = "User"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	alias              *string
	name               *string
	description        *string
	role               *account.Role
	created_date       *time.Time
	clearedFields      map[string]struct{}
	owner              *uuid.UUID
	clearedowner       bool
	silo               *uuid.UUID
	clearedsilo        bool
	memberships        map[uuid.UUID]struct{}
	removedmemberships map[uuid.UUID]struct{}
	clearedmemberships bool
	invitations        map[uuid.UUID]struct{}
	removedinvitations map[uuid.UUID]struct{}
	clearedinvitations bool
	done               bool
	oldValue           func(context.Context) (*Account, error)
	predicates         []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id uuid.UUID) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSiloID sets the "silo_id" field.
func (m *AccountMutation) SetSiloID(u uuid.UUID) {
	m.silo = &u
}

// SiloID returns the value of the "silo_id" field in the mutation.
func (m *AccountMutation) SiloID() (r uuid.UUID, exists bool) {
	v := m.silo
	if v == nil {
		return
	}
	return *v, true
}

// OldSiloID returns the old "silo_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSiloID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiloID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiloID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiloID: %w", err)
	}
	return oldValue.SiloID, nil
}

// ResetSiloID resets all changes to the "silo_id" field.
func (m *AccountMutation) ResetSiloID() {
	m.silo = nil
}

// SetAlias sets the "alias" field.
func (m *AccountMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *AccountMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *AccountMutation) ResetAlias() {
	m.alias = nil
}

// SetName sets the "name" field.
func (m *AccountMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AccountMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AccountMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *AccountMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *AccountMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *AccountMutation) ResetDescription() {
	m.description = nil
}

// SetRole sets the "role" field.
func (m *AccountMutation) SetRole(a account.Role) {
	m.role = &a
}

// Role returns the value of the "role" field in the mutation.
func (m *AccountMutation) Role() (r account.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRole(ctx context.Context) (v account.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AccountMutation) ResetRole() {
	m.role = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *AccountMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *AccountMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *AccountMutation) ResetCreatedDate() {
	m.created_date = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *AccountMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *AccountMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *AccountMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *AccountMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *AccountMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// ClearSilo clears the "silo" edge to the Silo entity.
func (m *AccountMutation) ClearSilo() {
	m.clearedsilo = true
	m.clearedFields[account.FieldSiloID] = struct{}{}
}

// SiloCleared reports if the "silo" edge to the Silo entity was cleared.
func (m *AccountMutation) SiloCleared() bool {
	return m.clearedsilo
}

// SiloIDs returns the "silo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SiloID instead. It exists only for internal usage by the builders.
func (m *AccountMutation) SiloIDs() (ids []uuid.UUID) {
	if id := m.silo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSilo resets all changes to the "silo" edge.
func (m *AccountMutation) ResetSilo() {
	m.silo = nil
	m.clearedsilo = false
}

// AddMembershipIDs adds the "memberships" edge to the Membership entity by ids.
func (m *AccountMutation) AddMembershipIDs(ids ...uuid.UUID) {
	if m.memberships == nil {
		m.memberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.memberships[ids[i]] = struct{}{}
	}
}

// ClearMemberships clears the "memberships" edge to the Membership entity.
func (m *AccountMutation) ClearMemberships() {
	m.clearedmemberships = true
}

// MembershipsCleared reports if the "memberships" edge to the Membership entity was cleared.
func (m *AccountMutation) MembershipsCleared() bool {
	return m.clearedmemberships
}

// RemoveMembershipIDs removes the "memberships" edge to the Membership entity by IDs.
func (m *AccountMutation) RemoveMembershipIDs(ids ...uuid.UUID) {
	if m.removedmemberships == nil {
		m.removedmemberships = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.memberships, ids[i])
		m.removedmemberships[ids[i]] = struct{}{}
	}
}

// RemovedMemberships returns the removed IDs of the "memberships" edge to the Membership entity.
func (m *AccountMutation) RemovedMembershipsIDs() (ids []uuid.UUID) {
	for id := range m.removedmemberships {
		ids = append(ids, id)
	}
	return
}

// MembershipsIDs returns the "memberships" edge IDs in the mutation.
func (m *AccountMutation) MembershipsIDs() (ids []uuid.UUID) {
	for id := range m.memberships {
		ids = append(ids, id)
	}
	return
}

// ResetMemberships resets all changes to the "memberships" edge.
func (m *AccountMutation) ResetMemberships() {
	m.memberships = nil
	m.clearedmemberships = false
	m.removedmemberships = nil
}

// AddInvitationIDs adds the "invitations" edge to the Invitation entity by ids.
func (m *AccountMutation) AddInvitationIDs(ids ...uuid.UUID) {
	if m.invitations == nil {
		m.invitations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the Invitation entity.
func (m *AccountMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the Invitation entity was cleared.
func (m *AccountMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the Invitation entity by IDs.
func (m *AccountMutation) RemoveInvitationIDs(ids ...uuid.UUID) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the Invitation entity.
func (m *AccountMutation) RemovedInvitationsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *AccountMutation) InvitationsIDs() (ids []uuid.UUID) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *AccountMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.silo != nil {
		fields = append(fields, account.FieldSiloID)
	}
	if m.alias != nil {
		fields = append(fields, account.FieldAlias)
	}
	if m.name != nil {
		fields = append(fields, account.FieldName)
	}
	if m.description != nil {
		fields = append(fields, account.FieldDescription)
	}
	if m.role != nil {
		fields = append(fields, account.FieldRole)
	}
	if m.created_date != nil {
		fields = append(fields, account.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldSiloID:
		return m.SiloID()
	case account.FieldAlias:
		return m.Alias()
	case account.FieldName:
		return m.Name()
	case account.FieldDescription:
		return m.Description()
	case account.FieldRole:
		return m.Role()
	case account.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldSiloID:
		return m.OldSiloID(ctx)
	case account.FieldAlias:
		return m.OldAlias(ctx)
	case account.FieldName:
		return m.OldName(ctx)
	case account.FieldDescription:
		return m.OldDescription(ctx)
	case account.FieldRole:
		return m.OldRole(ctx)
	case account.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldSiloID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiloID(v)
		return nil
	case account.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case account.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case account.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case account.FieldRole:
		v, ok := value.(account.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case account.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldSiloID:
		m.ResetSiloID()
		return nil
	case account.FieldAlias:
		m.ResetAlias()
		return nil
	case account.FieldName:
		m.ResetName()
		return nil
	case account.FieldDescription:
		m.ResetDescription()
		return nil
	case account.FieldRole:
		m.ResetRole()
		return nil
	case account.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.owner != nil {
		edges = append(edges, account.EdgeOwner)
	}
	if m.silo != nil {
		edges = append(edges, account.EdgeSilo)
	}
	if m.memberships != nil {
		edges = append(edges, account.EdgeMemberships)
	}
	if m.invitations != nil {
		edges = append(edges, account.EdgeInvitations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeSilo:
		if id := m.silo; id != nil {
			return []ent.Value{*id}
		}
	case account.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.memberships))
		for id := range m.memberships {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedmemberships != nil {
		edges = append(edges, account.EdgeMemberships)
	}
	if m.removedinvitations != nil {
		edges = append(edges, account.EdgeInvitations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeMemberships:
		ids := make([]ent.Value, 0, len(m.removedmemberships))
		for id := range m.removedmemberships {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedowner {
		edges = append(edges, account.EdgeOwner)
	}
	if m.clearedsilo {
		edges = append(edges, account.EdgeSilo)
	}
	if m.clearedmemberships {
		edges = append(edges, account.EdgeMemberships)
	}
	if m.clearedinvitations {
		edges = append(edges, account.EdgeInvitations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeOwner:
		return m.clearedowner
	case account.EdgeSilo:
		return m.clearedsilo
	case account.EdgeMemberships:
		return m.clearedmemberships
	case account.EdgeInvitations:
		return m.clearedinvitations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	case account.EdgeOwner:
		m.ClearOwner()
		return nil
	case account.EdgeSilo:
		m.ClearSilo()
		return nil
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeOwner:
		m.ResetOwner()
		return nil
	case account.EdgeSilo:
		m.ResetSilo()
		return nil
	case account.EdgeMemberships:
		m.ResetMemberships()
		return nil
	case account.EdgeInvitations:
		m.ResetInvitations()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// IdentityMutation represents an operation that mutates the Identity nodes in the graph.
type IdentityMutation struct {
	config
	op            Op
	typ           string
	id            *string
	kind          *string
	verifier      *string
	name          *string
	created_date  *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Identity, error)
	predicates    []predicate.Identity
}

var _ ent.Mutation = (*IdentityMutation)(nil)

// identityOption allows management of the mutation configuration using functional options.
type identityOption func(*IdentityMutation)

// newIdentityMutation creates new mutation for the Identity entity.
func newIdentityMutation(c config, op Op, opts ...identityOption) *IdentityMutation {
	m := &IdentityMutation{
		config:        c,
		op:            op,
		typ:           TypeIdentity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIdentityID sets the ID field of the mutation.
func withIdentityID(id string) identityOption {
	return func(m *IdentityMutation) {
		var (
			err   error
			once  sync.Once
			value *Identity
		)
		m.oldValue = func(ctx context.Context) (*Identity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Identity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIdentity sets the old Identity of the mutation.
func withIdentity(node *Identity) identityOption {
	return func(m *IdentityMutation) {
		m.oldValue = func(context.Context) (*Identity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IdentityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IdentityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Identity entities.
func (m *IdentityMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IdentityMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IdentityMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Identity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKind sets the "kind" field.
func (m *IdentityMutation) SetKind(s string) {
	m.kind = &s
}

// Kind returns the value of the "kind" field in the mutation.
func (m *IdentityMutation) Kind() (r string, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldKind(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *IdentityMutation) ResetKind() {
	m.kind = nil
}

// SetVerifier sets the "verifier" field.
func (m *IdentityMutation) SetVerifier(s string) {
	m.verifier = &s
}

// Verifier returns the value of the "verifier" field in the mutation.
func (m *IdentityMutation) Verifier() (r string, exists bool) {
	v := m.verifier
	if v == nil {
		return
	}
	return *v, true
}

// OldVerifier returns the old "verifier" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldVerifier(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVerifier is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVerifier requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVerifier: %w", err)
	}
	return oldValue.Verifier, nil
}

// ResetVerifier resets all changes to the "verifier" field.
func (m *IdentityMutation) ResetVerifier() {
	m.verifier = nil
}

// SetName sets the "name" field.
func (m *IdentityMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IdentityMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IdentityMutation) ResetName() {
	m.name = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *IdentityMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *IdentityMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Identity entity.
// If the Identity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IdentityMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *IdentityMutation) ResetCreatedDate() {
	m.created_date = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *IdentityMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *IdentityMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *IdentityMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *IdentityMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *IdentityMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *IdentityMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the IdentityMutation builder.
func (m *IdentityMutation) Where(ps ...predicate.Identity) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IdentityMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IdentityMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Identity, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IdentityMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IdentityMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Identity).
func (m *IdentityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IdentityMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.kind != nil {
		fields = append(fields, identity.FieldKind)
	}
	if m.verifier != nil {
		fields = append(fields, identity.FieldVerifier)
	}
	if m.name != nil {
		fields = append(fields, identity.FieldName)
	}
	if m.created_date != nil {
		fields = append(fields, identity.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IdentityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case identity.FieldKind:
		return m.Kind()
	case identity.FieldVerifier:
		return m.Verifier()
	case identity.FieldName:
		return m.Name()
	case identity.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IdentityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case identity.FieldKind:
		return m.OldKind(ctx)
	case identity.FieldVerifier:
		return m.OldVerifier(ctx)
	case identity.FieldName:
		return m.OldName(ctx)
	case identity.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown Identity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case identity.FieldKind:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	case identity.FieldVerifier:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVerifier(v)
		return nil
	case identity.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case identity.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IdentityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IdentityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IdentityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Identity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IdentityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IdentityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IdentityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Identity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IdentityMutation) ResetField(name string) error {
	switch name {
	case identity.FieldKind:
		m.ResetKind()
		return nil
	case identity.FieldVerifier:
		m.ResetVerifier()
		return nil
	case identity.FieldName:
		m.ResetName()
		return nil
	case identity.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown Identity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IdentityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, identity.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IdentityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case identity.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IdentityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IdentityMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IdentityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, identity.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IdentityMutation) EdgeCleared(name string) bool {
	switch name {
	case identity.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IdentityMutation) ClearEdge(name string) error {
	switch name {
	case identity.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Identity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IdentityMutation) ResetEdge(name string) error {
	switch name {
	case identity.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Identity edge %s", name)
}

// InvitationMutation represents an operation that mutates the Invitation nodes in the graph.
type InvitationMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	invitee        *string
	created_date   *time.Time
	expired_date   *time.Time
	accepted_date  *time.Time
	declined_date  *time.Time
	canceled_date  *time.Time
	clearedFields  map[string]struct{}
	silo           *uuid.UUID
	clearedsilo    bool
	inviter        *uuid.UUID
	clearedinviter bool
	done           bool
	oldValue       func(context.Context) (*Invitation, error)
	predicates     []predicate.Invitation
}

var _ ent.Mutation = (*InvitationMutation)(nil)

// invitationOption allows management of the mutation configuration using functional options.
type invitationOption func(*InvitationMutation)

// newInvitationMutation creates new mutation for the Invitation entity.
func newInvitationMutation(c config, op Op, opts ...invitationOption) *InvitationMutation {
	m := &InvitationMutation{
		config:        c,
		op:            op,
		typ:           TypeInvitation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInvitationID sets the ID field of the mutation.
func withInvitationID(id uuid.UUID) invitationOption {
	return func(m *InvitationMutation) {
		var (
			err   error
			once  sync.Once
			value *Invitation
		)
		m.oldValue = func(ctx context.Context) (*Invitation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Invitation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInvitation sets the old Invitation of the mutation.
func withInvitation(node *Invitation) invitationOption {
	return func(m *InvitationMutation) {
		m.oldValue = func(context.Context) (*Invitation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InvitationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InvitationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Invitation entities.
func (m *InvitationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InvitationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InvitationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Invitation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInvitee sets the "invitee" field.
func (m *InvitationMutation) SetInvitee(s string) {
	m.invitee = &s
}

// Invitee returns the value of the "invitee" field in the mutation.
func (m *InvitationMutation) Invitee() (r string, exists bool) {
	v := m.invitee
	if v == nil {
		return
	}
	return *v, true
}

// OldInvitee returns the old "invitee" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldInvitee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvitee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvitee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvitee: %w", err)
	}
	return oldValue.Invitee, nil
}

// ResetInvitee resets all changes to the "invitee" field.
func (m *InvitationMutation) ResetInvitee() {
	m.invitee = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *InvitationMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *InvitationMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *InvitationMutation) ResetCreatedDate() {
	m.created_date = nil
}

// SetExpiredDate sets the "expired_date" field.
func (m *InvitationMutation) SetExpiredDate(t time.Time) {
	m.expired_date = &t
}

// ExpiredDate returns the value of the "expired_date" field in the mutation.
func (m *InvitationMutation) ExpiredDate() (r time.Time, exists bool) {
	v := m.expired_date
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredDate returns the old "expired_date" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldExpiredDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredDate: %w", err)
	}
	return oldValue.ExpiredDate, nil
}

// ResetExpiredDate resets all changes to the "expired_date" field.
func (m *InvitationMutation) ResetExpiredDate() {
	m.expired_date = nil
}

// SetAcceptedDate sets the "accepted_date" field.
func (m *InvitationMutation) SetAcceptedDate(t time.Time) {
	m.accepted_date = &t
}

// AcceptedDate returns the value of the "accepted_date" field in the mutation.
func (m *InvitationMutation) AcceptedDate() (r time.Time, exists bool) {
	v := m.accepted_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAcceptedDate returns the old "accepted_date" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldAcceptedDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAcceptedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAcceptedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAcceptedDate: %w", err)
	}
	return oldValue.AcceptedDate, nil
}

// ResetAcceptedDate resets all changes to the "accepted_date" field.
func (m *InvitationMutation) ResetAcceptedDate() {
	m.accepted_date = nil
}

// SetDeclinedDate sets the "declined_date" field.
func (m *InvitationMutation) SetDeclinedDate(t time.Time) {
	m.declined_date = &t
}

// DeclinedDate returns the value of the "declined_date" field in the mutation.
func (m *InvitationMutation) DeclinedDate() (r time.Time, exists bool) {
	v := m.declined_date
	if v == nil {
		return
	}
	return *v, true
}

// OldDeclinedDate returns the old "declined_date" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldDeclinedDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeclinedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeclinedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeclinedDate: %w", err)
	}
	return oldValue.DeclinedDate, nil
}

// ResetDeclinedDate resets all changes to the "declined_date" field.
func (m *InvitationMutation) ResetDeclinedDate() {
	m.declined_date = nil
}

// SetCanceledDate sets the "canceled_date" field.
func (m *InvitationMutation) SetCanceledDate(t time.Time) {
	m.canceled_date = &t
}

// CanceledDate returns the value of the "canceled_date" field in the mutation.
func (m *InvitationMutation) CanceledDate() (r time.Time, exists bool) {
	v := m.canceled_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCanceledDate returns the old "canceled_date" field's value of the Invitation entity.
// If the Invitation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InvitationMutation) OldCanceledDate(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanceledDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanceledDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanceledDate: %w", err)
	}
	return oldValue.CanceledDate, nil
}

// ResetCanceledDate resets all changes to the "canceled_date" field.
func (m *InvitationMutation) ResetCanceledDate() {
	m.canceled_date = nil
}

// SetSiloID sets the "silo" edge to the Silo entity by id.
func (m *InvitationMutation) SetSiloID(id uuid.UUID) {
	m.silo = &id
}

// ClearSilo clears the "silo" edge to the Silo entity.
func (m *InvitationMutation) ClearSilo() {
	m.clearedsilo = true
}

// SiloCleared reports if the "silo" edge to the Silo entity was cleared.
func (m *InvitationMutation) SiloCleared() bool {
	return m.clearedsilo
}

// SiloID returns the "silo" edge ID in the mutation.
func (m *InvitationMutation) SiloID() (id uuid.UUID, exists bool) {
	if m.silo != nil {
		return *m.silo, true
	}
	return
}

// SiloIDs returns the "silo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SiloID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) SiloIDs() (ids []uuid.UUID) {
	if id := m.silo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSilo resets all changes to the "silo" edge.
func (m *InvitationMutation) ResetSilo() {
	m.silo = nil
	m.clearedsilo = false
}

// SetInviterID sets the "inviter" edge to the Account entity by id.
func (m *InvitationMutation) SetInviterID(id uuid.UUID) {
	m.inviter = &id
}

// ClearInviter clears the "inviter" edge to the Account entity.
func (m *InvitationMutation) ClearInviter() {
	m.clearedinviter = true
}

// InviterCleared reports if the "inviter" edge to the Account entity was cleared.
func (m *InvitationMutation) InviterCleared() bool {
	return m.clearedinviter
}

// InviterID returns the "inviter" edge ID in the mutation.
func (m *InvitationMutation) InviterID() (id uuid.UUID, exists bool) {
	if m.inviter != nil {
		return *m.inviter, true
	}
	return
}

// InviterIDs returns the "inviter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InviterID instead. It exists only for internal usage by the builders.
func (m *InvitationMutation) InviterIDs() (ids []uuid.UUID) {
	if id := m.inviter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInviter resets all changes to the "inviter" edge.
func (m *InvitationMutation) ResetInviter() {
	m.inviter = nil
	m.clearedinviter = false
}

// Where appends a list predicates to the InvitationMutation builder.
func (m *InvitationMutation) Where(ps ...predicate.Invitation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InvitationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InvitationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Invitation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InvitationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InvitationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Invitation).
func (m *InvitationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InvitationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.invitee != nil {
		fields = append(fields, invitation.FieldInvitee)
	}
	if m.created_date != nil {
		fields = append(fields, invitation.FieldCreatedDate)
	}
	if m.expired_date != nil {
		fields = append(fields, invitation.FieldExpiredDate)
	}
	if m.accepted_date != nil {
		fields = append(fields, invitation.FieldAcceptedDate)
	}
	if m.declined_date != nil {
		fields = append(fields, invitation.FieldDeclinedDate)
	}
	if m.canceled_date != nil {
		fields = append(fields, invitation.FieldCanceledDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InvitationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case invitation.FieldInvitee:
		return m.Invitee()
	case invitation.FieldCreatedDate:
		return m.CreatedDate()
	case invitation.FieldExpiredDate:
		return m.ExpiredDate()
	case invitation.FieldAcceptedDate:
		return m.AcceptedDate()
	case invitation.FieldDeclinedDate:
		return m.DeclinedDate()
	case invitation.FieldCanceledDate:
		return m.CanceledDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InvitationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case invitation.FieldInvitee:
		return m.OldInvitee(ctx)
	case invitation.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	case invitation.FieldExpiredDate:
		return m.OldExpiredDate(ctx)
	case invitation.FieldAcceptedDate:
		return m.OldAcceptedDate(ctx)
	case invitation.FieldDeclinedDate:
		return m.OldDeclinedDate(ctx)
	case invitation.FieldCanceledDate:
		return m.OldCanceledDate(ctx)
	}
	return nil, fmt.Errorf("unknown Invitation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case invitation.FieldInvitee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvitee(v)
		return nil
	case invitation.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	case invitation.FieldExpiredDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredDate(v)
		return nil
	case invitation.FieldAcceptedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAcceptedDate(v)
		return nil
	case invitation.FieldDeclinedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeclinedDate(v)
		return nil
	case invitation.FieldCanceledDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanceledDate(v)
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InvitationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InvitationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InvitationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Invitation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InvitationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InvitationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InvitationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Invitation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InvitationMutation) ResetField(name string) error {
	switch name {
	case invitation.FieldInvitee:
		m.ResetInvitee()
		return nil
	case invitation.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	case invitation.FieldExpiredDate:
		m.ResetExpiredDate()
		return nil
	case invitation.FieldAcceptedDate:
		m.ResetAcceptedDate()
		return nil
	case invitation.FieldDeclinedDate:
		m.ResetDeclinedDate()
		return nil
	case invitation.FieldCanceledDate:
		m.ResetCanceledDate()
		return nil
	}
	return fmt.Errorf("unknown Invitation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InvitationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.silo != nil {
		edges = append(edges, invitation.EdgeSilo)
	}
	if m.inviter != nil {
		edges = append(edges, invitation.EdgeInviter)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InvitationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case invitation.EdgeSilo:
		if id := m.silo; id != nil {
			return []ent.Value{*id}
		}
	case invitation.EdgeInviter:
		if id := m.inviter; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InvitationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InvitationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InvitationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsilo {
		edges = append(edges, invitation.EdgeSilo)
	}
	if m.clearedinviter {
		edges = append(edges, invitation.EdgeInviter)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InvitationMutation) EdgeCleared(name string) bool {
	switch name {
	case invitation.EdgeSilo:
		return m.clearedsilo
	case invitation.EdgeInviter:
		return m.clearedinviter
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InvitationMutation) ClearEdge(name string) error {
	switch name {
	case invitation.EdgeSilo:
		m.ClearSilo()
		return nil
	case invitation.EdgeInviter:
		m.ClearInviter()
		return nil
	}
	return fmt.Errorf("unknown Invitation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InvitationMutation) ResetEdge(name string) error {
	switch name {
	case invitation.EdgeSilo:
		m.ResetSilo()
		return nil
	case invitation.EdgeInviter:
		m.ResetInviter()
		return nil
	}
	return fmt.Errorf("unknown Invitation edge %s", name)
}

// MembershipMutation represents an operation that mutates the Membership nodes in the graph.
type MembershipMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	role           *membership.Role
	created_date   *time.Time
	clearedFields  map[string]struct{}
	account        *uuid.UUID
	clearedaccount bool
	team           *uuid.UUID
	clearedteam    bool
	done           bool
	oldValue       func(context.Context) (*Membership, error)
	predicates     []predicate.Membership
}

var _ ent.Mutation = (*MembershipMutation)(nil)

// membershipOption allows management of the mutation configuration using functional options.
type membershipOption func(*MembershipMutation)

// newMembershipMutation creates new mutation for the Membership entity.
func newMembershipMutation(c config, op Op, opts ...membershipOption) *MembershipMutation {
	m := &MembershipMutation{
		config:        c,
		op:            op,
		typ:           TypeMembership,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMembershipID sets the ID field of the mutation.
func withMembershipID(id uuid.UUID) membershipOption {
	return func(m *MembershipMutation) {
		var (
			err   error
			once  sync.Once
			value *Membership
		)
		m.oldValue = func(ctx context.Context) (*Membership, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Membership.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMembership sets the old Membership of the mutation.
func withMembership(node *Membership) membershipOption {
	return func(m *MembershipMutation) {
		m.oldValue = func(context.Context) (*Membership, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MembershipMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MembershipMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Membership entities.
func (m *MembershipMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MembershipMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MembershipMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Membership.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRole sets the "role" field.
func (m *MembershipMutation) SetRole(value membership.Role) {
	m.role = &value
}

// Role returns the value of the "role" field in the mutation.
func (m *MembershipMutation) Role() (r membership.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldRole(ctx context.Context) (v membership.Role, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *MembershipMutation) ResetRole() {
	m.role = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *MembershipMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *MembershipMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Membership entity.
// If the Membership object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MembershipMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *MembershipMutation) ResetCreatedDate() {
	m.created_date = nil
}

// SetAccountID sets the "account" edge to the Account entity by id.
func (m *MembershipMutation) SetAccountID(id uuid.UUID) {
	m.account = &id
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *MembershipMutation) ClearAccount() {
	m.clearedaccount = true
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *MembershipMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountID returns the "account" edge ID in the mutation.
func (m *MembershipMutation) AccountID() (id uuid.UUID, exists bool) {
	if m.account != nil {
		return *m.account, true
	}
	return
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) AccountIDs() (ids []uuid.UUID) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *MembershipMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// SetTeamID sets the "team" edge to the Team entity by id.
func (m *MembershipMutation) SetTeamID(id uuid.UUID) {
	m.team = &id
}

// ClearTeam clears the "team" edge to the Team entity.
func (m *MembershipMutation) ClearTeam() {
	m.clearedteam = true
}

// TeamCleared reports if the "team" edge to the Team entity was cleared.
func (m *MembershipMutation) TeamCleared() bool {
	return m.clearedteam
}

// TeamID returns the "team" edge ID in the mutation.
func (m *MembershipMutation) TeamID() (id uuid.UUID, exists bool) {
	if m.team != nil {
		return *m.team, true
	}
	return
}

// TeamIDs returns the "team" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TeamID instead. It exists only for internal usage by the builders.
func (m *MembershipMutation) TeamIDs() (ids []uuid.UUID) {
	if id := m.team; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTeam resets all changes to the "team" edge.
func (m *MembershipMutation) ResetTeam() {
	m.team = nil
	m.clearedteam = false
}

// Where appends a list predicates to the MembershipMutation builder.
func (m *MembershipMutation) Where(ps ...predicate.Membership) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MembershipMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MembershipMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Membership, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MembershipMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MembershipMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Membership).
func (m *MembershipMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MembershipMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.role != nil {
		fields = append(fields, membership.FieldRole)
	}
	if m.created_date != nil {
		fields = append(fields, membership.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MembershipMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case membership.FieldRole:
		return m.Role()
	case membership.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MembershipMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case membership.FieldRole:
		return m.OldRole(ctx)
	case membership.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown Membership field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) SetField(name string, value ent.Value) error {
	switch name {
	case membership.FieldRole:
		v, ok := value.(membership.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case membership.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MembershipMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MembershipMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MembershipMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Membership numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MembershipMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MembershipMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MembershipMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Membership nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MembershipMutation) ResetField(name string) error {
	switch name {
	case membership.FieldRole:
		m.ResetRole()
		return nil
	case membership.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown Membership field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MembershipMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.account != nil {
		edges = append(edges, membership.EdgeAccount)
	}
	if m.team != nil {
		edges = append(edges, membership.EdgeTeam)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MembershipMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case membership.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	case membership.EdgeTeam:
		if id := m.team; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MembershipMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MembershipMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MembershipMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedaccount {
		edges = append(edges, membership.EdgeAccount)
	}
	if m.clearedteam {
		edges = append(edges, membership.EdgeTeam)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MembershipMutation) EdgeCleared(name string) bool {
	switch name {
	case membership.EdgeAccount:
		return m.clearedaccount
	case membership.EdgeTeam:
		return m.clearedteam
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MembershipMutation) ClearEdge(name string) error {
	switch name {
	case membership.EdgeAccount:
		m.ClearAccount()
		return nil
	case membership.EdgeTeam:
		m.ClearTeam()
		return nil
	}
	return fmt.Errorf("unknown Membership unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MembershipMutation) ResetEdge(name string) error {
	switch name {
	case membership.EdgeAccount:
		m.ResetAccount()
		return nil
	case membership.EdgeTeam:
		m.ResetTeam()
		return nil
	}
	return fmt.Errorf("unknown Membership edge %s", name)
}

// SiloMutation represents an operation that mutates the Silo nodes in the graph.
type SiloMutation struct {
	config
	op                 Op
	typ                string
	id                 *uuid.UUID
	alias              *string
	name               *string
	description        *string
	created_date       *time.Time
	clearedFields      map[string]struct{}
	members            map[uuid.UUID]struct{}
	removedmembers     map[uuid.UUID]struct{}
	clearedmembers     bool
	teams              map[uuid.UUID]struct{}
	removedteams       map[uuid.UUID]struct{}
	clearedteams       bool
	invitations        map[uuid.UUID]struct{}
	removedinvitations map[uuid.UUID]struct{}
	clearedinvitations bool
	done               bool
	oldValue           func(context.Context) (*Silo, error)
	predicates         []predicate.Silo
}

var _ ent.Mutation = (*SiloMutation)(nil)

// siloOption allows management of the mutation configuration using functional options.
type siloOption func(*SiloMutation)

// newSiloMutation creates new mutation for the Silo entity.
func newSiloMutation(c config, op Op, opts ...siloOption) *SiloMutation {
	m := &SiloMutation{
		config:        c,
		op:            op,
		typ:           TypeSilo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSiloID sets the ID field of the mutation.
func withSiloID(id uuid.UUID) siloOption {
	return func(m *SiloMutation) {
		var (
			err   error
			once  sync.Once
			value *Silo
		)
		m.oldValue = func(ctx context.Context) (*Silo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Silo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSilo sets the old Silo of the mutation.
func withSilo(node *Silo) siloOption {
	return func(m *SiloMutation) {
		m.oldValue = func(context.Context) (*Silo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SiloMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SiloMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Silo entities.
func (m *SiloMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SiloMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SiloMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Silo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAlias sets the "alias" field.
func (m *SiloMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *SiloMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Silo entity.
// If the Silo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiloMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *SiloMutation) ResetAlias() {
	m.alias = nil
}

// SetName sets the "name" field.
func (m *SiloMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SiloMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Silo entity.
// If the Silo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiloMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SiloMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *SiloMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SiloMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Silo entity.
// If the Silo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiloMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SiloMutation) ResetDescription() {
	m.description = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *SiloMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *SiloMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Silo entity.
// If the Silo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SiloMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *SiloMutation) ResetCreatedDate() {
	m.created_date = nil
}

// AddMemberIDs adds the "members" edge to the Account entity by ids.
func (m *SiloMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Account entity.
func (m *SiloMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Account entity was cleared.
func (m *SiloMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Account entity by IDs.
func (m *SiloMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Account entity.
func (m *SiloMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *SiloMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *SiloMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// AddTeamIDs adds the "teams" edge to the Team entity by ids.
func (m *SiloMutation) AddTeamIDs(ids ...uuid.UUID) {
	if m.teams == nil {
		m.teams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.teams[ids[i]] = struct{}{}
	}
}

// ClearTeams clears the "teams" edge to the Team entity.
func (m *SiloMutation) ClearTeams() {
	m.clearedteams = true
}

// TeamsCleared reports if the "teams" edge to the Team entity was cleared.
func (m *SiloMutation) TeamsCleared() bool {
	return m.clearedteams
}

// RemoveTeamIDs removes the "teams" edge to the Team entity by IDs.
func (m *SiloMutation) RemoveTeamIDs(ids ...uuid.UUID) {
	if m.removedteams == nil {
		m.removedteams = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.teams, ids[i])
		m.removedteams[ids[i]] = struct{}{}
	}
}

// RemovedTeams returns the removed IDs of the "teams" edge to the Team entity.
func (m *SiloMutation) RemovedTeamsIDs() (ids []uuid.UUID) {
	for id := range m.removedteams {
		ids = append(ids, id)
	}
	return
}

// TeamsIDs returns the "teams" edge IDs in the mutation.
func (m *SiloMutation) TeamsIDs() (ids []uuid.UUID) {
	for id := range m.teams {
		ids = append(ids, id)
	}
	return
}

// ResetTeams resets all changes to the "teams" edge.
func (m *SiloMutation) ResetTeams() {
	m.teams = nil
	m.clearedteams = false
	m.removedteams = nil
}

// AddInvitationIDs adds the "invitations" edge to the Invitation entity by ids.
func (m *SiloMutation) AddInvitationIDs(ids ...uuid.UUID) {
	if m.invitations == nil {
		m.invitations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.invitations[ids[i]] = struct{}{}
	}
}

// ClearInvitations clears the "invitations" edge to the Invitation entity.
func (m *SiloMutation) ClearInvitations() {
	m.clearedinvitations = true
}

// InvitationsCleared reports if the "invitations" edge to the Invitation entity was cleared.
func (m *SiloMutation) InvitationsCleared() bool {
	return m.clearedinvitations
}

// RemoveInvitationIDs removes the "invitations" edge to the Invitation entity by IDs.
func (m *SiloMutation) RemoveInvitationIDs(ids ...uuid.UUID) {
	if m.removedinvitations == nil {
		m.removedinvitations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.invitations, ids[i])
		m.removedinvitations[ids[i]] = struct{}{}
	}
}

// RemovedInvitations returns the removed IDs of the "invitations" edge to the Invitation entity.
func (m *SiloMutation) RemovedInvitationsIDs() (ids []uuid.UUID) {
	for id := range m.removedinvitations {
		ids = append(ids, id)
	}
	return
}

// InvitationsIDs returns the "invitations" edge IDs in the mutation.
func (m *SiloMutation) InvitationsIDs() (ids []uuid.UUID) {
	for id := range m.invitations {
		ids = append(ids, id)
	}
	return
}

// ResetInvitations resets all changes to the "invitations" edge.
func (m *SiloMutation) ResetInvitations() {
	m.invitations = nil
	m.clearedinvitations = false
	m.removedinvitations = nil
}

// Where appends a list predicates to the SiloMutation builder.
func (m *SiloMutation) Where(ps ...predicate.Silo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SiloMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SiloMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Silo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SiloMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SiloMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Silo).
func (m *SiloMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SiloMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.alias != nil {
		fields = append(fields, silo.FieldAlias)
	}
	if m.name != nil {
		fields = append(fields, silo.FieldName)
	}
	if m.description != nil {
		fields = append(fields, silo.FieldDescription)
	}
	if m.created_date != nil {
		fields = append(fields, silo.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SiloMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case silo.FieldAlias:
		return m.Alias()
	case silo.FieldName:
		return m.Name()
	case silo.FieldDescription:
		return m.Description()
	case silo.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SiloMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case silo.FieldAlias:
		return m.OldAlias(ctx)
	case silo.FieldName:
		return m.OldName(ctx)
	case silo.FieldDescription:
		return m.OldDescription(ctx)
	case silo.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown Silo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiloMutation) SetField(name string, value ent.Value) error {
	switch name {
	case silo.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case silo.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case silo.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case silo.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown Silo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SiloMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SiloMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SiloMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Silo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SiloMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SiloMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SiloMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Silo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SiloMutation) ResetField(name string) error {
	switch name {
	case silo.FieldAlias:
		m.ResetAlias()
		return nil
	case silo.FieldName:
		m.ResetName()
		return nil
	case silo.FieldDescription:
		m.ResetDescription()
		return nil
	case silo.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown Silo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SiloMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.members != nil {
		edges = append(edges, silo.EdgeMembers)
	}
	if m.teams != nil {
		edges = append(edges, silo.EdgeTeams)
	}
	if m.invitations != nil {
		edges = append(edges, silo.EdgeInvitations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SiloMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case silo.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	case silo.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.teams))
		for id := range m.teams {
			ids = append(ids, id)
		}
		return ids
	case silo.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.invitations))
		for id := range m.invitations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SiloMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedmembers != nil {
		edges = append(edges, silo.EdgeMembers)
	}
	if m.removedteams != nil {
		edges = append(edges, silo.EdgeTeams)
	}
	if m.removedinvitations != nil {
		edges = append(edges, silo.EdgeInvitations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SiloMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case silo.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	case silo.EdgeTeams:
		ids := make([]ent.Value, 0, len(m.removedteams))
		for id := range m.removedteams {
			ids = append(ids, id)
		}
		return ids
	case silo.EdgeInvitations:
		ids := make([]ent.Value, 0, len(m.removedinvitations))
		for id := range m.removedinvitations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SiloMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedmembers {
		edges = append(edges, silo.EdgeMembers)
	}
	if m.clearedteams {
		edges = append(edges, silo.EdgeTeams)
	}
	if m.clearedinvitations {
		edges = append(edges, silo.EdgeInvitations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SiloMutation) EdgeCleared(name string) bool {
	switch name {
	case silo.EdgeMembers:
		return m.clearedmembers
	case silo.EdgeTeams:
		return m.clearedteams
	case silo.EdgeInvitations:
		return m.clearedinvitations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SiloMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Silo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SiloMutation) ResetEdge(name string) error {
	switch name {
	case silo.EdgeMembers:
		m.ResetMembers()
		return nil
	case silo.EdgeTeams:
		m.ResetTeams()
		return nil
	case silo.EdgeInvitations:
		m.ResetInvitations()
		return nil
	}
	return fmt.Errorf("unknown Silo edge %s", name)
}

// TeamMutation represents an operation that mutates the Team nodes in the graph.
type TeamMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	alias            *string
	name             *string
	description      *string
	inter_visibility *team.InterVisibility
	intra_visibility *team.IntraVisibility
	created_date     *time.Time
	clearedFields    map[string]struct{}
	silo             *uuid.UUID
	clearedsilo      bool
	members          map[uuid.UUID]struct{}
	removedmembers   map[uuid.UUID]struct{}
	clearedmembers   bool
	done             bool
	oldValue         func(context.Context) (*Team, error)
	predicates       []predicate.Team
}

var _ ent.Mutation = (*TeamMutation)(nil)

// teamOption allows management of the mutation configuration using functional options.
type teamOption func(*TeamMutation)

// newTeamMutation creates new mutation for the Team entity.
func newTeamMutation(c config, op Op, opts ...teamOption) *TeamMutation {
	m := &TeamMutation{
		config:        c,
		op:            op,
		typ:           TypeTeam,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTeamID sets the ID field of the mutation.
func withTeamID(id uuid.UUID) teamOption {
	return func(m *TeamMutation) {
		var (
			err   error
			once  sync.Once
			value *Team
		)
		m.oldValue = func(ctx context.Context) (*Team, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Team.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTeam sets the old Team of the mutation.
func withTeam(node *Team) teamOption {
	return func(m *TeamMutation) {
		m.oldValue = func(context.Context) (*Team, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TeamMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TeamMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Team entities.
func (m *TeamMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TeamMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TeamMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Team.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSiloID sets the "silo_id" field.
func (m *TeamMutation) SetSiloID(u uuid.UUID) {
	m.silo = &u
}

// SiloID returns the value of the "silo_id" field in the mutation.
func (m *TeamMutation) SiloID() (r uuid.UUID, exists bool) {
	v := m.silo
	if v == nil {
		return
	}
	return *v, true
}

// OldSiloID returns the old "silo_id" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldSiloID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiloID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiloID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiloID: %w", err)
	}
	return oldValue.SiloID, nil
}

// ResetSiloID resets all changes to the "silo_id" field.
func (m *TeamMutation) ResetSiloID() {
	m.silo = nil
}

// SetAlias sets the "alias" field.
func (m *TeamMutation) SetAlias(s string) {
	m.alias = &s
}

// Alias returns the value of the "alias" field in the mutation.
func (m *TeamMutation) Alias() (r string, exists bool) {
	v := m.alias
	if v == nil {
		return
	}
	return *v, true
}

// OldAlias returns the old "alias" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldAlias(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlias is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlias requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlias: %w", err)
	}
	return oldValue.Alias, nil
}

// ResetAlias resets all changes to the "alias" field.
func (m *TeamMutation) ResetAlias() {
	m.alias = nil
}

// SetName sets the "name" field.
func (m *TeamMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TeamMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TeamMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *TeamMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *TeamMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *TeamMutation) ResetDescription() {
	m.description = nil
}

// SetInterVisibility sets the "inter_visibility" field.
func (m *TeamMutation) SetInterVisibility(tv team.InterVisibility) {
	m.inter_visibility = &tv
}

// InterVisibility returns the value of the "inter_visibility" field in the mutation.
func (m *TeamMutation) InterVisibility() (r team.InterVisibility, exists bool) {
	v := m.inter_visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldInterVisibility returns the old "inter_visibility" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldInterVisibility(ctx context.Context) (v team.InterVisibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterVisibility: %w", err)
	}
	return oldValue.InterVisibility, nil
}

// ResetInterVisibility resets all changes to the "inter_visibility" field.
func (m *TeamMutation) ResetInterVisibility() {
	m.inter_visibility = nil
}

// SetIntraVisibility sets the "intra_visibility" field.
func (m *TeamMutation) SetIntraVisibility(tv team.IntraVisibility) {
	m.intra_visibility = &tv
}

// IntraVisibility returns the value of the "intra_visibility" field in the mutation.
func (m *TeamMutation) IntraVisibility() (r team.IntraVisibility, exists bool) {
	v := m.intra_visibility
	if v == nil {
		return
	}
	return *v, true
}

// OldIntraVisibility returns the old "intra_visibility" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldIntraVisibility(ctx context.Context) (v team.IntraVisibility, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIntraVisibility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIntraVisibility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIntraVisibility: %w", err)
	}
	return oldValue.IntraVisibility, nil
}

// ResetIntraVisibility resets all changes to the "intra_visibility" field.
func (m *TeamMutation) ResetIntraVisibility() {
	m.intra_visibility = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *TeamMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *TeamMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the Team entity.
// If the Team object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TeamMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *TeamMutation) ResetCreatedDate() {
	m.created_date = nil
}

// ClearSilo clears the "silo" edge to the Silo entity.
func (m *TeamMutation) ClearSilo() {
	m.clearedsilo = true
	m.clearedFields[team.FieldSiloID] = struct{}{}
}

// SiloCleared reports if the "silo" edge to the Silo entity was cleared.
func (m *TeamMutation) SiloCleared() bool {
	return m.clearedsilo
}

// SiloIDs returns the "silo" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SiloID instead. It exists only for internal usage by the builders.
func (m *TeamMutation) SiloIDs() (ids []uuid.UUID) {
	if id := m.silo; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSilo resets all changes to the "silo" edge.
func (m *TeamMutation) ResetSilo() {
	m.silo = nil
	m.clearedsilo = false
}

// AddMemberIDs adds the "members" edge to the Membership entity by ids.
func (m *TeamMutation) AddMemberIDs(ids ...uuid.UUID) {
	if m.members == nil {
		m.members = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.members[ids[i]] = struct{}{}
	}
}

// ClearMembers clears the "members" edge to the Membership entity.
func (m *TeamMutation) ClearMembers() {
	m.clearedmembers = true
}

// MembersCleared reports if the "members" edge to the Membership entity was cleared.
func (m *TeamMutation) MembersCleared() bool {
	return m.clearedmembers
}

// RemoveMemberIDs removes the "members" edge to the Membership entity by IDs.
func (m *TeamMutation) RemoveMemberIDs(ids ...uuid.UUID) {
	if m.removedmembers == nil {
		m.removedmembers = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.members, ids[i])
		m.removedmembers[ids[i]] = struct{}{}
	}
}

// RemovedMembers returns the removed IDs of the "members" edge to the Membership entity.
func (m *TeamMutation) RemovedMembersIDs() (ids []uuid.UUID) {
	for id := range m.removedmembers {
		ids = append(ids, id)
	}
	return
}

// MembersIDs returns the "members" edge IDs in the mutation.
func (m *TeamMutation) MembersIDs() (ids []uuid.UUID) {
	for id := range m.members {
		ids = append(ids, id)
	}
	return
}

// ResetMembers resets all changes to the "members" edge.
func (m *TeamMutation) ResetMembers() {
	m.members = nil
	m.clearedmembers = false
	m.removedmembers = nil
}

// Where appends a list predicates to the TeamMutation builder.
func (m *TeamMutation) Where(ps ...predicate.Team) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TeamMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TeamMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Team, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TeamMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TeamMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Team).
func (m *TeamMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TeamMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.silo != nil {
		fields = append(fields, team.FieldSiloID)
	}
	if m.alias != nil {
		fields = append(fields, team.FieldAlias)
	}
	if m.name != nil {
		fields = append(fields, team.FieldName)
	}
	if m.description != nil {
		fields = append(fields, team.FieldDescription)
	}
	if m.inter_visibility != nil {
		fields = append(fields, team.FieldInterVisibility)
	}
	if m.intra_visibility != nil {
		fields = append(fields, team.FieldIntraVisibility)
	}
	if m.created_date != nil {
		fields = append(fields, team.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TeamMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case team.FieldSiloID:
		return m.SiloID()
	case team.FieldAlias:
		return m.Alias()
	case team.FieldName:
		return m.Name()
	case team.FieldDescription:
		return m.Description()
	case team.FieldInterVisibility:
		return m.InterVisibility()
	case team.FieldIntraVisibility:
		return m.IntraVisibility()
	case team.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TeamMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case team.FieldSiloID:
		return m.OldSiloID(ctx)
	case team.FieldAlias:
		return m.OldAlias(ctx)
	case team.FieldName:
		return m.OldName(ctx)
	case team.FieldDescription:
		return m.OldDescription(ctx)
	case team.FieldInterVisibility:
		return m.OldInterVisibility(ctx)
	case team.FieldIntraVisibility:
		return m.OldIntraVisibility(ctx)
	case team.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown Team field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) SetField(name string, value ent.Value) error {
	switch name {
	case team.FieldSiloID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiloID(v)
		return nil
	case team.FieldAlias:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlias(v)
		return nil
	case team.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case team.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case team.FieldInterVisibility:
		v, ok := value.(team.InterVisibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterVisibility(v)
		return nil
	case team.FieldIntraVisibility:
		v, ok := value.(team.IntraVisibility)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIntraVisibility(v)
		return nil
	case team.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TeamMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TeamMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TeamMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Team numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TeamMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TeamMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TeamMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Team nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TeamMutation) ResetField(name string) error {
	switch name {
	case team.FieldSiloID:
		m.ResetSiloID()
		return nil
	case team.FieldAlias:
		m.ResetAlias()
		return nil
	case team.FieldName:
		m.ResetName()
		return nil
	case team.FieldDescription:
		m.ResetDescription()
		return nil
	case team.FieldInterVisibility:
		m.ResetInterVisibility()
		return nil
	case team.FieldIntraVisibility:
		m.ResetIntraVisibility()
		return nil
	case team.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown Team field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TeamMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.silo != nil {
		edges = append(edges, team.EdgeSilo)
	}
	if m.members != nil {
		edges = append(edges, team.EdgeMembers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TeamMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeSilo:
		if id := m.silo; id != nil {
			return []ent.Value{*id}
		}
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.members))
		for id := range m.members {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TeamMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedmembers != nil {
		edges = append(edges, team.EdgeMembers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TeamMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case team.EdgeMembers:
		ids := make([]ent.Value, 0, len(m.removedmembers))
		for id := range m.removedmembers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TeamMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsilo {
		edges = append(edges, team.EdgeSilo)
	}
	if m.clearedmembers {
		edges = append(edges, team.EdgeMembers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TeamMutation) EdgeCleared(name string) bool {
	switch name {
	case team.EdgeSilo:
		return m.clearedsilo
	case team.EdgeMembers:
		return m.clearedmembers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TeamMutation) ClearEdge(name string) error {
	switch name {
	case team.EdgeSilo:
		m.ClearSilo()
		return nil
	}
	return fmt.Errorf("unknown Team unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TeamMutation) ResetEdge(name string) error {
	switch name {
	case team.EdgeSilo:
		m.ResetSilo()
		return nil
	case team.EdgeMembers:
		m.ResetMembers()
		return nil
	}
	return fmt.Errorf("unknown Team edge %s", name)
}

// TokenMutation represents an operation that mutates the Token nodes in the graph.
type TokenMutation struct {
	config
	op            Op
	typ           string
	id            *string
	_type         *string
	name          *string
	created_at    *time.Time
	expired_at    *time.Time
	clearedFields map[string]struct{}
	owner         *uuid.UUID
	clearedowner  bool
	done          bool
	oldValue      func(context.Context) (*Token, error)
	predicates    []predicate.Token
}

var _ ent.Mutation = (*TokenMutation)(nil)

// tokenOption allows management of the mutation configuration using functional options.
type tokenOption func(*TokenMutation)

// newTokenMutation creates new mutation for the Token entity.
func newTokenMutation(c config, op Op, opts ...tokenOption) *TokenMutation {
	m := &TokenMutation{
		config:        c,
		op:            op,
		typ:           TypeToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTokenID sets the ID field of the mutation.
func withTokenID(id string) tokenOption {
	return func(m *TokenMutation) {
		var (
			err   error
			once  sync.Once
			value *Token
		)
		m.oldValue = func(ctx context.Context) (*Token, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Token.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withToken sets the old Token of the mutation.
func withToken(node *Token) tokenOption {
	return func(m *TokenMutation) {
		m.oldValue = func(context.Context) (*Token, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Token entities.
func (m *TokenMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TokenMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TokenMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Token.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *TokenMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TokenMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TokenMutation) ResetType() {
	m._type = nil
}

// SetName sets the "name" field.
func (m *TokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TokenMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TokenMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetExpiredAt sets the "expired_at" field.
func (m *TokenMutation) SetExpiredAt(t time.Time) {
	m.expired_at = &t
}

// ExpiredAt returns the value of the "expired_at" field in the mutation.
func (m *TokenMutation) ExpiredAt() (r time.Time, exists bool) {
	v := m.expired_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiredAt returns the old "expired_at" field's value of the Token entity.
// If the Token object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TokenMutation) OldExpiredAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiredAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiredAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiredAt: %w", err)
	}
	return oldValue.ExpiredAt, nil
}

// ResetExpiredAt resets all changes to the "expired_at" field.
func (m *TokenMutation) ResetExpiredAt() {
	m.expired_at = nil
}

// SetOwnerID sets the "owner" edge to the User entity by id.
func (m *TokenMutation) SetOwnerID(id uuid.UUID) {
	m.owner = &id
}

// ClearOwner clears the "owner" edge to the User entity.
func (m *TokenMutation) ClearOwner() {
	m.clearedowner = true
}

// OwnerCleared reports if the "owner" edge to the User entity was cleared.
func (m *TokenMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerID returns the "owner" edge ID in the mutation.
func (m *TokenMutation) OwnerID() (id uuid.UUID, exists bool) {
	if m.owner != nil {
		return *m.owner, true
	}
	return
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TokenMutation) OwnerIDs() (ids []uuid.UUID) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TokenMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TokenMutation builder.
func (m *TokenMutation) Where(ps ...predicate.Token) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Token, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Token).
func (m *TokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TokenMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._type != nil {
		fields = append(fields, token.FieldType)
	}
	if m.name != nil {
		fields = append(fields, token.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, token.FieldCreatedAt)
	}
	if m.expired_at != nil {
		fields = append(fields, token.FieldExpiredAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case token.FieldType:
		return m.GetType()
	case token.FieldName:
		return m.Name()
	case token.FieldCreatedAt:
		return m.CreatedAt()
	case token.FieldExpiredAt:
		return m.ExpiredAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case token.FieldType:
		return m.OldType(ctx)
	case token.FieldName:
		return m.OldName(ctx)
	case token.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case token.FieldExpiredAt:
		return m.OldExpiredAt(ctx)
	}
	return nil, fmt.Errorf("unknown Token field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case token.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case token.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case token.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case token.FieldExpiredAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiredAt(v)
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Token numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TokenMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TokenMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Token nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TokenMutation) ResetField(name string) error {
	switch name {
	case token.FieldType:
		m.ResetType()
		return nil
	case token.FieldName:
		m.ResetName()
		return nil
	case token.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case token.FieldExpiredAt:
		m.ResetExpiredAt()
		return nil
	}
	return fmt.Errorf("unknown Token field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.owner != nil {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case token.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedowner {
		edges = append(edges, token.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TokenMutation) EdgeCleared(name string) bool {
	switch name {
	case token.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TokenMutation) ClearEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown Token unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TokenMutation) ResetEdge(name string) error {
	switch name {
	case token.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown Token edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	name              *string
	created_date      *time.Time
	clearedFields     map[string]struct{}
	identities        map[string]struct{}
	removedidentities map[string]struct{}
	clearedidentities bool
	accounts          map[uuid.UUID]struct{}
	removedaccounts   map[uuid.UUID]struct{}
	clearedaccounts   bool
	tokens            map[string]struct{}
	removedtokens     map[string]struct{}
	clearedtokens     bool
	done              bool
	oldValue          func(context.Context) (*User, error)
	predicates        []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id uuid.UUID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
}

// SetCreatedDate sets the "created_date" field.
func (m *UserMutation) SetCreatedDate(t time.Time) {
	m.created_date = &t
}

// CreatedDate returns the value of the "created_date" field in the mutation.
func (m *UserMutation) CreatedDate() (r time.Time, exists bool) {
	v := m.created_date
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedDate returns the old "created_date" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedDate: %w", err)
	}
	return oldValue.CreatedDate, nil
}

// ResetCreatedDate resets all changes to the "created_date" field.
func (m *UserMutation) ResetCreatedDate() {
	m.created_date = nil
}

// AddIdentityIDs adds the "identities" edge to the Identity entity by ids.
func (m *UserMutation) AddIdentityIDs(ids ...string) {
	if m.identities == nil {
		m.identities = make(map[string]struct{})
	}
	for i := range ids {
		m.identities[ids[i]] = struct{}{}
	}
}

// ClearIdentities clears the "identities" edge to the Identity entity.
func (m *UserMutation) ClearIdentities() {
	m.clearedidentities = true
}

// IdentitiesCleared reports if the "identities" edge to the Identity entity was cleared.
func (m *UserMutation) IdentitiesCleared() bool {
	return m.clearedidentities
}

// RemoveIdentityIDs removes the "identities" edge to the Identity entity by IDs.
func (m *UserMutation) RemoveIdentityIDs(ids ...string) {
	if m.removedidentities == nil {
		m.removedidentities = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.identities, ids[i])
		m.removedidentities[ids[i]] = struct{}{}
	}
}

// RemovedIdentities returns the removed IDs of the "identities" edge to the Identity entity.
func (m *UserMutation) RemovedIdentitiesIDs() (ids []string) {
	for id := range m.removedidentities {
		ids = append(ids, id)
	}
	return
}

// IdentitiesIDs returns the "identities" edge IDs in the mutation.
func (m *UserMutation) IdentitiesIDs() (ids []string) {
	for id := range m.identities {
		ids = append(ids, id)
	}
	return
}

// ResetIdentities resets all changes to the "identities" edge.
func (m *UserMutation) ResetIdentities() {
	m.identities = nil
	m.clearedidentities = false
	m.removedidentities = nil
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *UserMutation) AddAccountIDs(ids ...uuid.UUID) {
	if m.accounts == nil {
		m.accounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *UserMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *UserMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *UserMutation) RemoveAccountIDs(ids ...uuid.UUID) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *UserMutation) RemovedAccountsIDs() (ids []uuid.UUID) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *UserMutation) AccountsIDs() (ids []uuid.UUID) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *UserMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddTokenIDs adds the "tokens" edge to the Token entity by ids.
func (m *UserMutation) AddTokenIDs(ids ...string) {
	if m.tokens == nil {
		m.tokens = make(map[string]struct{})
	}
	for i := range ids {
		m.tokens[ids[i]] = struct{}{}
	}
}

// ClearTokens clears the "tokens" edge to the Token entity.
func (m *UserMutation) ClearTokens() {
	m.clearedtokens = true
}

// TokensCleared reports if the "tokens" edge to the Token entity was cleared.
func (m *UserMutation) TokensCleared() bool {
	return m.clearedtokens
}

// RemoveTokenIDs removes the "tokens" edge to the Token entity by IDs.
func (m *UserMutation) RemoveTokenIDs(ids ...string) {
	if m.removedtokens == nil {
		m.removedtokens = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.tokens, ids[i])
		m.removedtokens[ids[i]] = struct{}{}
	}
}

// RemovedTokens returns the removed IDs of the "tokens" edge to the Token entity.
func (m *UserMutation) RemovedTokensIDs() (ids []string) {
	for id := range m.removedtokens {
		ids = append(ids, id)
	}
	return
}

// TokensIDs returns the "tokens" edge IDs in the mutation.
func (m *UserMutation) TokensIDs() (ids []string) {
	for id := range m.tokens {
		ids = append(ids, id)
	}
	return
}

// ResetTokens resets all changes to the "tokens" edge.
func (m *UserMutation) ResetTokens() {
	m.tokens = nil
	m.clearedtokens = false
	m.removedtokens = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.created_date != nil {
		fields = append(fields, user.FieldCreatedDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldName:
		return m.Name()
	case user.FieldCreatedDate:
		return m.CreatedDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldCreatedDate:
		return m.OldCreatedDate(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldCreatedDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedDate(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldCreatedDate:
		m.ResetCreatedDate()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.identities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.accounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.tokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.identities))
		for id := range m.identities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.tokens))
		for id := range m.tokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedidentities != nil {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.removedaccounts != nil {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.removedtokens != nil {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeIdentities:
		ids := make([]ent.Value, 0, len(m.removedidentities))
		for id := range m.removedidentities {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeTokens:
		ids := make([]ent.Value, 0, len(m.removedtokens))
		for id := range m.removedtokens {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedidentities {
		edges = append(edges, user.EdgeIdentities)
	}
	if m.clearedaccounts {
		edges = append(edges, user.EdgeAccounts)
	}
	if m.clearedtokens {
		edges = append(edges, user.EdgeTokens)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeIdentities:
		return m.clearedidentities
	case user.EdgeAccounts:
		return m.clearedaccounts
	case user.EdgeTokens:
		return m.clearedtokens
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeIdentities:
		m.ResetIdentities()
		return nil
	case user.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case user.EdgeTokens:
		m.ResetTokens()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
